\documentclass[pdftex,11pt,a4paper]{article}
\usepackage{../cs444}

\begin{document}

\titlemake{1}

This document outlines the design of a scanner and parser for
the Joos 1W language as specified by the Java Language Specification
2.0 (JLS) and the course website
\url{https://www.student.cs.uwaterloo.ca/~cs444/joos.html}. It also
discusses some challenges faced while implementing the scanner and
parser, as well as our strategy for testing correctness.

Code is written in Ruby, and our implementation of the scanner and
lexer is located in \texttt{lib/}. Our copy of the Marmoset tests are
located in \texttt{test/}, and our own tests are located in
\texttt{spec/}. Offline tasks, such as running our parser generator
are located in \texttt{rakelib/}. All tasks that might have been in
the \texttt{Makefile} are delegate to tasks defined in
\texttt{rakelib/}.

\section{Design}

Some fluffy preamble to design talk goes here.

The design of the scanning and parsing phases of our compiler are
broken up into five sections: the herp for derp, the foo for bar, the
baz for quux, hurr for durr, and AST for the final data structure that
we construct in this portion of the course.


\subsection{Tokens}

The interface between the lexer and the parser is a stream
(\texttt{Array}) of \texttt{Joos::Token} objects. \texttt{Joos::Token}
is an abstract base class which contains encodes the original value of
the token, the type of the token, and metadata related to where the
token originated.

Concrete subclasses are created for each keyword, operator, separator,
and literal type, as defined in the JLS. A concrete class for
identifiers is also created. Classes may \texttt{include} modifiers
which attach extra metadata to a token.

The class itself specifies the type of the token. For instance, a
token representing the keyword \texttt{while} will be contained by an
instance of the \texttt{Joos::Token::While} class, and a token
representing a litertal \texttt{true} will be contained by an instance
of the \texttt{Joos::Token::True} class. Identifiers are wrapped by
\texttt{Joos::Token::Identifier}, literal integers by
\texttt{Joos::Token::Integer}, and so on.

Each token will contain metadata that can be used for diagnostic
purposes: the relative path to the file where the token comes from,
the line in the file where the token comes from, and the column in the
line where the token begins.

Additional metadata is attached to different groupings of token
classes to create a sort of hierarchy.


\subsection{Lexer}

It does stuff with a DFA and generates a stream of tokens from code
input. Rejecting non-ASCII code is handled during this phase.


\subsection{Abstract Syntax Tree}

Or whatever data abstraction we end up with for parsing.


\subsection{Parser}

It takes a stream of tokens from the lexer and does some other stuff.


\section{Challenges}


This is where the interesting shit goes. Talk about anything that did
not follow simply from class. This is a required section of the report.


\subsection{Weeder}

Magic! Reject all programs that use non-Joos keywords, literal
integers that are outside of allowed ranges, and strings that include
invalid escape sequences.


\subsection{Duplicate String Literals}

Literal string duplication is avoided by overriding how
\texttt{Joos::Token::String} objects are allocated. We override the
default allocation method for the class and check if another string
with the same binary value already exists. If it the string already
exists we return the existing token instead of a new token. The trade
off here is that we lose any metadata attached to the duplicate
literal string, such as the file and line where the string came from;
so any compilation errors related to the string may point to the
incorrect string, depending on the type of error. We compare against
the binary form of the string so that differences in escape sequences
do not affect the detection of duplicate strings.

I should probably modify this strategy a bit so that we actually keep
duplicate literal strings during the analysis phase of compilation,
and just link their in memory address when it comes to code
generation.


\section{Testing}

We wrote tests. And we also have an offline version of marmoset tests
which we run in the student environment at roflscale.

This section is required, so we have to fill it out at some point\ldots


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
