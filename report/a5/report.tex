\documentclass[pdftex,11pt,a4paper]{article}
\usepackage{../cs444}

\begin{document}

\titlemake{5}

This document outlines the design of the code generation phase of
the Joos 1W language implemented by our compiler to target the
\ttt{i386} Linux platform as well as the \ttt{i386} OS X (darwin)
platform.


\section{Design}

The design of code generation starts by generating static data needed
for the Joos runtime, and then creating and running an instance of the
\ttt{CodeGenerator} class for each compilation unit, as well as one
instance for the \ttt{Array} pseudo-class.

The result is that a single assembly file is generated for each
compilation unit, as well as one for \ttt{Array}, and a copy of our
runtime library is also made. All output files are placed into
\ttt{outptut/}.


\subsection{Static Data}

The Joos runtime requires various pieces of data that must can be
statically determined at compile time and placed into the \ttt{data}
section of the generated assembly code.

\subsubsection{Type Checking}

In order to support the `instanceof` operator, down cast checking, and
array element assignment, we are required to have hierarchy information
available at runtime so that we can check perform a type check on the
object. The required check can be paraphrased as ``is the required
type an ancestor of the type of the concrete data?'', where the
required type would be the right operand of `instanceof`, the cast
type for a down cast, or the inner type of an array.

The first observation we made was that the requirement of these three
runtime checks is very similar, the only exception being how
\ttt{null} concrete data is handled. The first step in our solution is
to assign a unique number to each compilation unit, we called this the
\ttt{ancestor\_number}. Then, we create a list for each concrete data
type (each \ttt{Class} which is not abstract), which contains every
possible type that an instance of that concrete class could be
assigned. Finally, a null terminated list is output in the \ttt{data}
section of the output file for the compilation unit containing the
\ttt{ancestor\_number}s.

The list is accessed at runtime in the class data, which is reachable
by concrete data via the concrete data's tag. To actually perform the
checks, instructions for `instanceof`, down casting, and array element
assignment are generated to check the \ttt{ancestor\_number} by
linearly scanning through the table.

In practice, class hierarchies are not very deep, and so these tables
are quite small. For the marmoset test cases, the ancestor list is two
or three entries. So we think this solution is reasonably fast and
compact.

\subsubsection{Dynamic Dispatch}

In Joos, static methods and constructors are monomorphic functions,
and calling these functions can be done simply by knowing the label
for the function and using the \ttt{call} instruction. However,
instance methods are not always monomorphic, and require a runtime
lookup to find the address of the method implementation.

Similar to runtime type checking, we assign a number to each concrete
method signature declared for the program. However, we then also
assign numbers to each abstract method signature which has a concrete
implementation. This is to help with finding the correct method number
during instruction generation when we may only have a reference to an
abstract method implementation.

The number assigned to each method is then used as the index into a
sparse table. Each instantiable type is given a table as part of the
types static data. Empty entries in the table are given a null
pointer. At runtime, a concrete object can reach the table via its
tag.

Since Joos does not support any form of dynamic code loading, we would
have liked to perform an analysis to check which instance methods were
actually monomorphic, so that we could optimize those method calls and
reduce the size of the vtable. However, we did not have time to
implement this feature.

In fact, the assignment specifications and standard library do not
provide any way for input to be given to a Joos program. The only
output is the exit code and string output to standard output. The
ultimate optimization would have been to interpret the Joos program in
the compiler and generate assembly code that simply printed out any
strings that the program would have printed, and exit with the
appropriate code.


\subsubsection{Static Fields}

Code generation for static fields is done in two steps. The first step
is allocate space for the static value in the \ttt{data} section of
the program. Each field is given a double word of space for storage
for convenience. The default value for each static field is \ttt{00},
which is the correct default initialzation value for Joos data no
matter what type information is used to interpret the bits.

The second step is to generate a function that will be called during
program initialization to initialize the field. However, static fields
with no initializer will not have a function generated.

Each compilation unit has a single function which calls all the static
field initializers, in the order that they were declared in the source
program. This single function is then called by the program's main
function before calling the Joos \ttt{test()} method. Organizing
initializers with this hierarchy was simply to keep information more
compartmentalized.

\subsubsection{String Literals}

String literal objects are created each string literal in a
compilation unit.

\subsection{Dynamic Data}

Object layout

Field offsets

Arrays


\subsection{Generating Assembly Skeleton Files}

Symbol names, prefixing, etc\ldots

What goes in the runtime library

Program startup


\subsection{Conventions}

Calling convention

Local function layout


\subsection{Substance}

Register allocator

SSA


\section{Testing}

Testing for code generation was done by implementing unit tests,
example Joos programs, and by using the available public tests from
Marmoset.

SSA compilation testing was done with unit testing by writing small
programs and testing that the output matched exactly with what was
expected. Test programs were created for each type of SSA
instruction.

The standard library \ttt{runtime.s} was ported to OS X. As well, our
entire runtime was written to support both \ttt{i386} Linux and \ttt{i386} OS
X. The compiler will compile for the platform that it is executed
from, and tests platform using the \ttt{uname} program. The only
challenge that we had with OS X support was discovering the correct
linker incantation to link with the system C library. Linking with the
C library was necessary in order to call \ttt{malloc} as OS X does not
support the system calls which was used by the Linux runtime library
provided in the standard library. Our workaround is to use
\ttt{clang}, the C compiler for OS X, which will make the appropriate
calls to the linker.

The Joos runtime was written while SSA compilation was still being
implemented, and so we could not test the library by compiling
programs. Our strategy was to create mock Joos objects in assembly,
and test the inidividual functions by passing the mock objects. It was
simple to perform rudimentary checks for boolean values and null
pointers in assembly, and exit with an appropriate exit code.

In addition to checking the result of a runtime function, we
implemented a function for printing full strings to standard output,
by using the example from the standard library runtime. This function
allowed us to output explicit exception class names when exiting with
an exception, instead of just exiting with exit code 13. However, this
functionality is disabled in the submitted code just in case it would
interfere with expected output.

For system level testing, we wrote example Joos programs to test edge
cases in expected side effect behaviour and exception behaviour. These
tests included testing that constructors initialize fields and call the
super constructor in the correct order, and array bounds checking
tests. We also wrote some basic programs, such as bubble sort, to
exercise various other components of code generation.

The test programs were added to the collection of public tests
available from Marmoset. We relied on Marmoset test for assignment 5,
and some from previous assignments that were relevant to assignment 5,
to fully exercise our code generator.

However, the Marmoset test harness required various changes in order
to manage files that were output by the compiler. Namely, we had to
change the compiler to allow the output directory to be configurable,
with a default value of \ttt{output/}, so that the test suite was able
parallelize compilation of test cases correctly. Interestingly, we
found that tests that ran extremely slowly are hidden by all the tests
which run quickly due to the parallelization.

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
