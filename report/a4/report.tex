\documentclass[pdftex,11pt,a4paper]{article}
\usepackage{../cs444}

\begin{document}

\titlemake{4}

This document outlines the design of name resolution, type checking,
and other static analysis phases of the Joos 1W language as
implemented in our compiler. It also discusses some challenges faced
while implementing these phases.


\section{Design}

All components of the compiler implemented for name resolution, type
checking, and static analysis are centered around the AST. Either by
transforming the AST, replacing portions of the AST with more
conveinent data structures, or by appending functionality to classes
which are already part of the AST. After parsing was completed, the
compiler had an AST for each compilation unit (file) which was named
on the command line. We then begin building up entity structures for
each compilation unit in order to simplify environment building
and name resolution.

\subsection{Entities}

The first step in building the type environment was to create an
\ttt{Entity} class to represent each type of declared Java entity. We
define an entity in the same way that the JLS does:

\begin{quote}
A declared entity is a \tbf{package}, \tbf{class} type,
\tbf{interface} type, member (class,interface, \tbf{field}, or
\tbf{method}) of a reference type, \tbf{parameter} (to a method,
constructor, or exception handler), or \tbf{local variable}.
\end{quote}

For the entities which Joos supports; \ttt{Package}, \ttt{Class},
\ttt{Interface}, \ttt{Field}, \ttt{Method}, \ttt{Parameter}, and
\ttt{LocalVariable}; we have created classes that make accessing the
metadata of the entity easier and more efficient than repeatedly
navigating an AST, and share a common superclass of \ttt{Entity}.

The \ttt{Compiler} object keeps a reference to each \ttt{Class} or
\ttt{Interface} compilation unit that is being declared, as well as
the root pseudo \ttt{Package}.

\subsection{Package Hierarchy}

The root package is only a pseudo package; it has no name, and is not
equivalent to the unnamed default package specified by the JLS. The
root pseudo package exists only to provide a convenient container for
packages which do not have a parent package. For instance,
the \ttt{java.lang.Object} class declares that it belongs to package
\ttt{java.lang}; which would create a \ttt{Package} named \ttt{java}
that is a member of the root pseudo package. \ttt{java.lang}
would also create a \ttt{Package} named \ttt{lang} which is a member
of the \ttt{java} package. Finally, the \ttt{Class} named
\ttt{Object} whose compilation unit declared the package, will be
added as a member of the \ttt{lang} package.

Each \ttt{Package}, \ttt{Class}, and \ttt{Interface} will become a
member of some \ttt{Package}, and all be part of the same namespace.
In this manner, we can iterate over each compilation unit
and, if the compilation unit declares a package, we can create the
required hierarchy of packages and then add the compilation unit to
the package.

If a compilation unit does not declare a package, it will be added to
the special default package, as specified in the JLS. Though the JLS
allows for multiple default packages, we found it necessary to have
only a single default package in order to pass Marmoset tests.

If a package declaration names a package which clashes with an already
declared compilation unit, then an error is printed and compilation is
aborted. A similar result occurs if a compilation unit's fully
qualified name would be the same as the fully qualified name of a
package. For instance, if a compilation unit declared
\ttt{package java.lang.Object;} as its package, there would be an
error because a compilation unit, \ttt{Class java.lang.Object},
already exists.

\subsubsection{Type Environment}

To complete the type environment, for each compilation unit, we parsed
the \ttt{import} statements from each compilation unit and searched
through the package hierarchy starting from the root pseudo
package. Since \ttt{import} is required to use fully qualified names,
we know that if a single-type import names a \ttt{Package} then that
is an error, and if a package import names a \ttt{Class} or
\ttt{Interface}, then it is also an error. If nothing is found in the
package hierarchy, then that is also an error.

For single-type imports, we keep an ordered list of compilation unit
entities that were named by single-type import statements. Duplicate
single type imports are considered errors and will cause compilation
to abort with an error message. Similarly, single type imports where
the simple name of the compilation clashes with a previous single type
import, or the simple name of the compilation unit, will also be
treated as an error in the source code.

For package imports, we keep a list of \ttt{Package} entities that
were named by package import statements. The implicit
\ttt{java.lang.*} package import is done first, and then any other
package imports follow.

Each compilation unit then gets its own list of single type imports
and package imports, and shares a reference to the root pseudo
package. This tuple of information forms the type environment for a
compilation unit, and is used to resolve names which must name a
type. It is also used to help disambiguate ambiguous names during name
resolution and type checking.

\subsection{Building The Entity Hierarchy Skeleton}

Once the package hierarchy and type environment are built, we proceed
with building the entity hierarchy for each compilation unit, which
will replace parts of the AST.

For each \ttt{Class}, we parse the \ttt{extends} and \ttt{implements}
clauses of the declaration header, and link the names using the type
environment.  We then proceed to build an entity for each
\ttt{Constructor}, \ttt{Method}, and \ttt{Field} declared in the body
of the \ttt{Class}, maintaining an ordered list for each type of
entity.

For each class member, we resolve the return type to either a basic
type, an array of a basic type, or we must search the type environment
of the compilation unit to resolve the named type or named type
array. If the type name cannot resolve then we print an appropriate
error message and abort compilation. One exception to this process is
that we treat the return type of a constructor to be \ttt{void}, as
that is equivalent to the semantics required by the JLS and allows
more code reuse between entities.

\ttt{Interface} declarations follow the same process for building
their entity hierarchy, with the obvious exception that there will not
be any \ttt{Field} or \ttt{Constructor} declarations for an
\ttt{Interface}.

Then, for each \ttt{FormalParameter} of a \ttt{Method} or
\ttt{Constructor}, we follow the same process for resolving the
type. Resolving the types of local variable declarations and
allocations is deferred until after hierarchy checking.

\subsubsection{Hierarchy Checking}

We perform hierarchy checking as soon as enough of the hierarchy is
constructed, which is described in the previous section.

Linking classes and interfaces in the hierarchy occurs in essentially
two passes. In the first pass, we link superclasses and
superinterfaces and check simple constraints. One of the most
important checks is the circularity check, which is done in the
obvious way by recursively traversing up the class hierarchy. This
check ensures that the second pass of hierarchy checking terminates.

In the second pass, we link members to their class or interface. We also link
overridden methods to their parent and compute the contains set (called
\ttt{all\_methods} and \ttt{all\_fields}) for each class and interface. To do
this, we traverse the interface hierarchy, and then the class hierarchy in
breadth-first order: we sort by an attribute \ttt{depth}, which is 0 for
\ttt{java.lang.Object} and \ttt{superclass.depth + 1} (resp. \ttt{max
superinterfaces.depth + 1}) for every other class (interface). The contains set
of a class or interface (a simple array of \ttt{Method} or \ttt{Field} objects)
is actually computed by taking an outer join of the class' own members with the
contains set of its parent, joining by the signature of the member.  Visiting
each class / interface ordered by depth means that the contains sets of the
superclass and superinterfaces are guaranteed to be complete.

Finally, as part of the second pass, non-abstract classes check their
contains set to ensure that they have no abstract methods and all
their interfaces are implemented. Other checks are done along the way
in the obvious fashion.

\subsection{Completing The Entity Hierarchy}

Once hierachy checking is completed, we build entities for
\ttt{LocalVariableDeclaration}s, resolving their type using the type
environment, and resolve types for allocation expressions that use
\ttt{new}. Though there are other parts of an expression or expression
statement which must refer to a type, we defer resolving those types
until type checking.

The decision to separate some of the type resolution phase was the
result of how the Marmoset test suites are split up between assignment
3 and assignment, and our desire to use the Marmoset test suite for
additional regression tests.

\subsection{Type Checking}



\subsection{AST Transformations}

Due to the limitations of our LR(1) grammar, an AST may have some
peculiarities in its structure. This is necessary for creating an
unambiguous and more simple grammar, but also makes post-parsing
operations on the tree more difficult due the many different
structures that are created to model very similar concepts.

To get around this obstacle, we perform simple transformations on each
AST while it is being built, and then afterward during validation of
the ASTs.

\subsubsection{\ttt{for-while} Transformation}

The simplest transformations is transforming every intance of a
\ttt{for} loop to a \ttt{while} loop.

The initialization of the \ttt{for} loop is transformed into a \ttt{Statement}
(if one exists) and is placed as the first statement of the \ttt{Block} of
the new \ttt{while} loop. Since newly declared variables in the initialization
should only be in the scope of the following \ttt{Block}, we are easily able
to cover that behaviour with this method.

The update of the \ttt{for} loop is also transformed into a \ttt{Statement},
and is placed as the last statement of the \ttt{while} loop's \ttt{Block},
allowing that update to occur at the end of each iteration of the loop, as
expected.

The condition of the \ttt{for} loop is placed directly into the condition of
the \ttt{while} loop to preserve behaviour. Since \ttt{while} loops require a
condition, and \ttt{for} loops do not, we place the \ttt{true} condition into
the \ttt{while} loop automatically if the \ttt{for} loop does not have an
update clause.

The \ttt{Block} or \ttt{Statement} following the \ttt{for} loop is converted
into a \ttt{Block} (if applicable), and has the initialization and update
added to it (again, if applicable). This new block is used as the \ttt{while}
loop's following \ttt{Block}.

\subsubsection{Inner Block Scoping}

For each \ttt{Block}, we maintain a list of all identifiers declared in
that \ttt{Block}. However, this leads to an odering problem, as we are making
the assumption that each declaration in the \ttt{Block} occurs before the
corresponding identifier is referenced within the \ttt{Block}.

To deal with this, we add more inner \ttt{Blocks} to the \ttt{Block} in
question. We iterate over each statement in the \ttt{Block}, and if we see a
declaration occur after a statement, we wrap the declaration and all following
statements in a new block. This way, there is only ever one declaration per
block (all others are inside inner blocks), and any identifier that is
declared in one block should only be referenced in an inner block.

\subsubsection{Order of Operations}

Since our grammar does not preserve Joos's operator precedence, we need to
restructure any \ttt{SubExpression} to follow order of operations.

Each valid Joos operation is given a priority, with multiplication, division,
and modulus receiving highest priority (parentheses are taken care of by the
grammar), and lazy-or having the lowest priority. We pass over the
\ttt{SubExpression} from right to left, performing a simple rotation if
the operator precedence requires it, and recursively checking precedence on the
new subtree created.

After this pass, the \ttt{SubExpression} tree is in the correct shape for
following Joos's operator precedence.

\subsubsection{Constant Folding}

We fold constant expressions into a single constant at the same time we perform
type analysis (see below).

As a preface, a \ttt{SubExpression}, in our AST, is either a \ttt{Term} containing some value, or two more \ttt{SubExpressions} with an operator in
between.

Each \ttt{SubExpression} has a \ttt{literal\_value} denoting the its literal
value, if it has one. This literal value is either the literal value of its
\ttt{Term} (if that's its structure), or recursively defined as the literal
value of its two \ttt{SubExpression} children acted upon by the operator. If
a \ttt{SubExpression} or \ttt{Term} does not contain a literal value, then
\ttt{literal\_value} is denoted to us by the Ruby \ttt{nil}.

Once we have the \ttt{literal\_value} of a \ttt{SubExpression}, we replace the
inside of that \ttt{SubExpression} with a \ttt{Term} containing that literal
value.

Environment building\ldots


Linking identifiers\ldots


\subsubsection{Forward Reference Checks}

Forward reference checks on field initializers are done by structural recursion
on the initializer's AST. For every field reference that belongs to the same
class and has the same staticness as the field, we checks whether or not it is
the same or appears later in the class declaration. One tricky case is when the
initialized field is the target of an assignment. We handle this by checking a
flag that is set on the left branch of an assignment, and cleared for any
sub-expression that is not a simple identifier.


\section{Challenges}

This phase of the compiler implementation presented many
challenges, some of which led to interesting solutions.

AST transformations


\subsection{Hacks}

Lots and lots of hacks\ldots

AST transformations


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
