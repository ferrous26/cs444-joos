\documentclass[pdftex,11pt,a4paper]{article}
\usepackage{../cs444}

\begin{document}

\titlemake{4}

This document outlines the design of name resolution, type checking,
and other static analysis phases of the Joos 1W language as
implemented in our compiler. It also discusses some challenges faced
while implementing these phases.


\section{Design}

All components of the compiler implemented for name resolution, type
checking, and static analysis are centered around the AST. Either by
transforming the AST, replacing portions of the AST with more
conveinent non-tree structures, or injecting functionality.


, transforming, post parsing, are Various components of the thingy were designed by augmenting or
replacing the ASTs that were generated from parsing. We have one AST
for each compilation unit that we are compiling. For the first
assignment there was only ever one AST, but as of the second
assignment the compiler handles an arbitrary number of ASTs being
created and processed.

\subsection{AST Transformations}

Due to the limitations of our LR(1) grammar, an AST may have some peculiarities
in its structure. This is necessary for creating an unambiguous and more
simple grammar, but also makes post-parsing operations on the tree more
difficult due the many different structures that are created to model very
similar concepts.

To get around this obstacle, we perform simple transformations on each AST
while it is being built, and then afterward during validation of the ASTs.

\subsubsection{\ttt{for-while} Transformation}

One of the most simple transformations is transforming every intance of a
\ttt{for} loop to a \ttt{while} loop.

The initialization of the \ttt{for} loop is transformed into a \ttt{Statement}
(if one exists) and is placed as the first statement of the \ttt{Block} of
the new \ttt{while} loop. Since newly declared variables in the initialization
should only be in the scope of the following \ttt{Block}, we are easily able
to cover that behaviour with this method.

The update of the \ttt{for} loop is also transformed into a \ttt{Statement},
and is placed as the last statement of the \ttt{while} loop's \ttt{Block},
allowing that update to occur at the end of each iteration of the loop, as
expected.

The condition of the \ttt{for} loop is placed directly into the condition of
the \ttt{while} loop to preserve behaviour. Since \ttt{while} loops require a
condition, and \ttt{for} loops do not, we place the \ttt{true} condition into
the \ttt{while} loop automatically if the \ttt{for} loop does not have an
update clause.

The \ttt{Block} or \ttt{Statement} following the \ttt{for} loop is converted
into a \ttt{Block} (if applicable), and has the initialization and update
added to it (again, if applicable). This new block is used as the \ttt{while}
loop's following \ttt{Block}.

\subsubsection{Inner Block Scoping}

For each \ttt{Block}, we maintain a list of all identifiers declared in
that \ttt{Block}. However, this leads to an odering problem, as we are making
the assumption that each declaration in the \ttt{Block} occurs before the
corresponding identifier is referenced within the \ttt{Block}.

To deal with this, we add more inner \ttt{Blocks} to the \ttt{Block} in
question. We iterate over each statement in the \ttt{Block}, and if we see a
declaration occur after a statement, we wrap the declaration and all following
statements in a new block. This way, there is only ever one declaration per
block (all others are inside inner blocks), and any identifier that is
declared in one block should only be referenced in an inner block.

\subsubsection{Order of Operations}

Since our grammar does not preserve Joos's operator precedence, we need to
restructure any \ttt{SubExpression} to follow order of operations.

Each valid Joos operation is given a priority, with multiplication, division,
and modulus receiving highest priority (parentheses are taken care of by the
grammar), and lazy-or having the lowest priority. We pass over the
\ttt{SubExpression} from right to left, performing a simple rotation if
the operator precedence requires it, and recursively checking precedence on the
new subtree created.

After this pass, the \ttt{SubExpression} tree is in the correct shape for
following Joos's operator precedence.

\subsubsection{Constant Folding}

We fold constant expressions into a single constant at the same time we perform
type analysis (see below).

As a preface, a \ttt{SubExpression}, in our AST, is either a \ttt{Term} containing some value, or two more \ttt{SubExpressions} with an operator in
between.

Each \ttt{SubExpression} has a \ttt{literal_value} denoting the its literal
value, if it has one. This literal value is either the literal value of its
\ttt{Term} (if that's its structure), or recursively defined as the literal
value of its two \ttt{SubExpression} children acted upon by the operator. If
a \ttt{SubExpression} or \ttt{Term} does not contain a literal value, then
\ttt{literal_value} is denoted to us by the Ruby \ttt{nil}.

Once we have the \ttt{literal_value} of a \ttt{SubExpression}, we replace the
inside of that \ttt{SubExpression} with a \ttt{Term} containing that literal
value.

\subsection{Name Resolution}

The first step in name resolution was to parse each AST and create
entity objects for each type of declared entity. We define an entity
in the same way that the JLS does:

\begin{quote}
A declared entity is a \tbf{package}, \tbf{class} type,
\tbf{interface} type, member (class,interface, \tbf{field}, or
\tbf{method}) of a reference type, \tbf{parameter} (to a method,
constructor, or exception handler), or \tbf{local variable}.
\end{quote}

For the entities that Joos supports; \ttt{Package}, \ttt{Class},
\ttt{Interface}, \ttt{Field}, \ttt{Method}, \ttt{Parameter}, and
\ttt{LocalVariable}; we have created classes that make accessing the
metadata of the entity easier and more efficient than repeatedly
navigating an AST.


\subsubsection{Type Environment}

After initially parsing the AST into the entity models, we can build
the type environment by building the package hierarchy and linking
imported types and packages into the compilation units that request
them.

Creating the package hierarchy\ldots

Importing\ldots

Resolving type names




\subsubsection{Hierarchy Checking}

Linking classes and interfaces occurs in essentially two passes. In the first
pass, we link superclasses and superinterfaces and check simple constraints. One
of the most important checks is the circularity check, which is done in the
obvious way by recursively traversing up the class hierarchy. This check ensures
that the second pass terminates.

In the second pass, we link members to their class or interface. We also link
overridden methods to their parent and compute the contains set (called
\ttt{all\_methods}) for each class and interface. To do this, we traverse first
the interface hierarchy, then the class hierarchy in breadth-first order,
starting with \ttt{java.lang.Object}, then its sub-classes, their sub-classes,
and so on. The contains set of a class / interface (a simple array of
\ttt{Method} or \ttt{Field} objects) is computed by taking an outer join of the
class' own members with the contains set of its parent, joining by method name
and argument types. Because of the ordering, the contains sets of the superclass
and superinterfaces are guaranteed to be complete.

Finally, as part of the second pass, non-abstract classes check their contains
set to ensure that they have no abstract methods and all their interfaces are
implemented. Other checks are done along the way in the obvious fashion.


Environment building\ldots


Linking identifiers\ldots


\subsubsection{Forward Reference Checks}

Forward reference checks on field initializers are done by structural recursion
on the initializer's AST. For every field reference that belongs to the same
class and has the same staticness as the field, we checks whether or not it is
the same or appears later in the class declaration. One tricky case is when the
initialized field is the target of an assignment. We handle this by checking a
flag that is set on the left branch of an assignment, and cleared for any
sub-expression that is not a simple identifier.


\section{Challenges}

This phase of the compiler implementation presented many
challenges, some of which led to interesting solutions.

AST transformations


\subsection{Hacks}

Lots and lots of hacks\ldots

AST transformations


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
