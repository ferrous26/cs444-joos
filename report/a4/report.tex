\documentclass[pdftex,11pt,a4paper]{article}
\usepackage{../cs444}

\begin{document}

\titlemake{4}

This document outlines the design of name resolution, type checking,
and other static analysis phases of the Joos 1W language as
implemented in our compiler. It also discusses some challenges faced
while implementing these phases.


\section{Design}

All components of the compiler implemented for name resolution, type
checking, and static analysis are centered around the AST. Either by
transforming the AST, replacing portions of the AST with more
conveinent non-tree structures, or injecting functionality.


, transforming, post parsing, are Various components of the thingy were designed by augmenting or
replacing the ASTs that were generated from parsing. We have one AST
for each compilation unit that we are compiling. For the first
assignment there was only ever one AST, but as of the second
assignment the compiler handles an arbitrary number of ASTs being
created and processed.

\subsection{Name Resolution}

The first step in name resolution was to parse each AST and create
entity objects for each type of declared entity. We define an entity
in the same way that the JLS does:

\begin{quote}
A declared entity is a \tbf{package}, \tbf{class} type,
\tbf{interface} type, member (class,interface, \tbf{field}, or
\tbf{method}) of a reference type, \tbf{parameter} (to a method,
constructor, or exception handler), or \tbf{local variable}.
\end{quote}

For the entities that Joos supports; \ttt{Package}, \ttt{Class},
\ttt{Interface}, \ttt{Field}, \ttt{Method}, \ttt{Parameter}, and
\ttt{LocalVariable}; we have created classes that make accessing the
metadata of the entity easier and more efficient than repeatedly
navigating an AST.


\subsubsection{Type Environment}

After initially parsing the AST into the entity models, we can build
the type environment by building the package hierarchy and linking
imported types and packages into the compilation units that request
them.

Creating the package hierarchy\ldots

Importing\ldots

Resolving type names




\subsubsection{Hierarchy Checking}

Linking classes and interfaces occurs in essentially two passes. In the first
pass, we link superclasses and superinterfaces and check simple constraints. One
of the most important checks is the circularity check, which is done in the
obvious way by recursively traversing up the class hierarchy. This check ensures
that the second pass terminates.

In the second pass, we link members to their class or interface. We also link
overridden methods to their parent and compute the contains set (called
\ttt{all\_methods}) for each class and interface. To do this, we traverse first
the interface hierarchy, then the class hierarchy in breadth-first order,
starting with \ttt{java.lang.Object}, then its sub-classes, their sub-classes,
and so on. The contains set of a class / interface (a simple array of
\ttt{Method} or \ttt{Field} objects) is computed by taking an outer join of the
class' own members with the contains set of its parent, joining by method name
and argument types. Because of the ordering, the contains sets of the superclass
and superinterfaces are guaranteed to be complete.

Finally, as part of the second pass, non-abstract classes check their contains
set to ensure that they have no abstract methods and all their interfaces are
implemented. Other checks are done along the way in the obvious fashion.


Environment building\ldots


Linking identifiers\ldots


\subsubsection{Forward Reference Checks}

Forward reference checks on field initializers are done by structural recursion
on the initializer's AST. For every field reference that belongs to the same
class and has the same staticness as the field, we checks whether or not it is
the same or appears later in the class declaration. One tricky case is when the
initialized field is the target of an assignment. We handle this by checking a
flag that is set on the left branch of an assignment, and cleared for any
sub-expression that is not a simple identifier.


\section{Challenges}

This phase of the compiler implementation presented many
challenges, some of which led to interesting solutions.

AST transformations


\subsection{Hacks}

Lots and lots of hacks\ldots

AST transformations


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
